#+title: Readme


* What
This project aims to create a contextual command palette for any X program. It should be easy to configure (without coding), and flexible.


* Architecture
- Rofi
- JSON file for configuration
-

* How it works
I'm using =myrmidon= as inspiration, though rewriting everything in python for readability and extensibility.

* Initialization
:PROPERTIES:
:LAST_EXEC: 2023-02-14 21:14:40
:END:
#+begin_src shell

mkdir -p ~/.config/rofi-contextual-palette/
#+end_src

#+RESULTS:

#+begin_src json :tangle ~/.config/rofi-contextual-palette/config
{
"version": "0.1"
}
#+end_src


#+begin_src json
[
  {
    "name": "desk switch",
    "command": "rofi -show window",
    "tags": "desktop"
  },
  {
    "name": "win switch",
    "command": "rofi -show windowcd",
    "tags": "desktop"
  },
  {
    "name": "bookmarks",
    "command": "/home/charlie/.local/bin/rofi-buku",
    "tags": "web,buku,firefox"
  },
  {
    "name": "emoji",
    "command": "rofimoji",
    "tags": "writing,desktop"
  },
  {
    "name": "systemd",
    "command": "/home/charlie/.local/bin/rofi-systemd",
    "tags": "system,desktop"
  },
  {
    "name": "playlist",
    "command": "/home/charlie/.local/bin/rofi-mpd -p",
    "tags": "music,desktop"
  },
  {
    "name": "archivos",
    "command": "pcmanfm",
    "tags": "files"
  },
  {
    "name": "mpc",
    "command": "/home/charlie/.local/bin/rofi-mpc",
    "tags": "music"
  },
  {
    "name": "temas",
    "command": "/home/charlie/.local/bin/rofi-mpd -t",
    "tags": "music"
  }
]

#+end_src
* Program
:PROPERTIES:
:header-args: :tangle ./rofi-contextual-palette.py
:END:

** Header and docstring
#+begin_src python :shebang #!/usr/bin/env python
"""
DO NOT edit this file! Tangled from `Projects/rofi-command-palette/README.org`
Carlos Jose Barroso <carlos@cjbarroso.com> Feb 2023

"""
# Now, if we recognize one of the windows we filter the commands for that context.
# I may add a "general" instance of the launcher with all the commands, or maybe
# just prioritize some commands. Other alternative (with can be mixed really) is to
# have several instances.
# The idea of having a contextual one maybe has more value with seldom used apps, or
# heavily specialized environments.
#+end_src
** Imports
#+begin_src python
import os
import sys
import json
import subprocess
#+end_src
** Constants
#+begin_src python
CONFIG=os.path.expanduser("~/.config/rofi-contextual-palette/config")
TASKS=os.path.expanduser("~/.config/rofi-contextual-palette/task-list.json")

#+end_src

** Open config file
#+begin_src python
try:
    configfile = open(CONFIG)
except FileNotFoundError:
    print(f"No config file found at {CONFIG}")
    sys.exit()
#+end_src

** Open tasks file
#+begin_src python
try:
    tasksfile = open(TASKS)
except FileNotFoundError:
    print(f"No tasks file found at {TASKS}")
    sys.exit()
#+end_src

** Process json task list

#+begin_src python
try:
    raw_tasks = json.loads(tasksfile.read())
except json.decoder.JSONDecodeError as e:
    print("Error reading tasks file - Corrupt?")
    print(str(e))
#+end_src
** Get currently focused window class name
:PROPERTIES:
:LAST_EXEC: 2023-02-14 21:52:56
:END:
To use as a filter over the tags  column in the task list.

#+begin_src python
res=subprocess.run(["xdotool", "getwindowfocus", "getwindowclassname"], capture_output=True)
# remove carriage return and normalize to lower case
focused_window_class=res.stdout.decode("utf-8").strip().lower()
print(focused_window_class)
#+end_src

#+RESULTS:
** Get the generic task list
These are the tasks that are always included, though in a lower priority (TBD how to deprioritize)
#+begin_src python
generic_tasks = [e['label'] for e in raw_tasks if 'desktop' in e['app'] ]
print("generic tasks: ", generic_tasks)
#+end_src
** Filter the task list using the class name
:PROPERTIES:
:LAST_EXEC: 2023-02-14 22:06:48
:END:
The column is called "tags"
#+begin_src python
print("-"*80)
print("raw:", raw_tasks)
class_tasks = [e['label'] for e in raw_tasks if focused_window_class in e['app']]
print("class: ", class_tasks)
#+end_src

#+RESULTS:
** Merge the lists
#+begin_src python
merged_tasks_list = class_tasks + generic_tasks
merged_tasks_prepare = [f"{e}\0icon\x1fsystem-run" for e in merged_tasks_list]
merged_tasks = "\n".join(merged_tasks_prepare).encode("utf-8")
#+end_src
** Run rofi with the merged tasks
#+begin_src python
# es un objeto que se comporta como str()

selected_task_obj = subprocess.run(
    ["rofi", "-dmenu","-matching","fuzzy","-i","-p",f"[{focused_window_class}] Search tasks"],
    input=merged_tasks, capture_output=True
)

if selected_task_obj.returncode:
    print("something's wrong")
    sys.exit()

#+end_src
** Find the corresponding command
#+begin_src python
selected_task = selected_task_obj.stdout.decode().strip()

command = filter(lambda _: selected_task in _['label'], raw_tasks)
# verify if it exists, etc
#+end_src
** Run the command
#+begin_src python
# try, etc,
to_run = list(command).pop()['command']
subprocess.run(to_run.split(" ")) # split required
#+end_src
* Support scripts
** List passwords from special tab in copyq

#+begin_src shell :tangle ~/.local/bin/rofi-copyq-passwords.sh :shebang #!/usr/bin/env bash
copyq tab pass read $(seq 0 50) | sed '/^$/d' | rofi -dmenu -i -p "Secure password"
#+end_src
