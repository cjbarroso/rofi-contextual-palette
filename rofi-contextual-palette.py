#!/usr/bin/env python
"""
DO NOT edit this file! Tangled from `Projects/rofi-command-palette/README.org`
Carlos Jose Barroso <carlos@cjbarroso.com> Feb 2023

"""
# Now, if we recognize one of the windows we filter the commands for that context.
# I may add a "general" instance of the launcher with all the commands, or maybe
# just prioritize some commands. Other alternative (with can be mixed really) is to
# have several instances.
# The idea of having a contextual one maybe has more value with seldom used apps, or
# heavily specialized environments.

import os
import sys
import json
import subprocess

CONFIG=os.path.expanduser("~/.config/rofi-contextual-palette/config")
TASKS=os.path.expanduser("~/.config/rofi-contextual-palette/task-list.json")

try:
    configfile = open(CONFIG)
except FileNotFoundError:
    print(f"No config file found at {CONFIG}")
    sys.exit()

try:
    tasksfile = open(TASKS)
except FileNotFoundError:
    print(f"No tasks file found at {TASKS}")
    sys.exit()

try:
    raw_tasks = json.loads(tasksfile.read())
except json.decoder.JSONDecodeError as e:
    print("Error reading tasks file - Corrupt?")
    print(str(e))

res=subprocess.run(["xdotool", "getwindowfocus", "getwindowclassname"], capture_output=True)
# remove carriage return and normalize to lower case
focused_window_class=res.stdout.decode("utf-8").strip().lower()
print(focused_window_class)

generic_tasks = [e['label'] for e in raw_tasks if 'desktop' in e['app'] ]
print("generic tasks: ", generic_tasks)

print("-"*80)
print("raw:", raw_tasks)
class_tasks = [e['label'] for e in raw_tasks if focused_window_class in e['app']]
print("class: ", class_tasks)

merged_tasks_list = class_tasks + generic_tasks
merged_tasks_prepare = [f"{e}\0icon\x1fsystem-run" for e in merged_tasks_list]
merged_tasks = "\n".join(merged_tasks_prepare).encode("utf-8")

# es un objeto que se comporta como str()

selected_task_obj = subprocess.run(
    ["rofi", "-dmenu","-matching","fuzzy","-i","-p",f"[{focused_window_class}] Search tasks"],
    input=merged_tasks, capture_output=True
)

if selected_task_obj.returncode:
    print("something's wrong")
    sys.exit()

selected_task = selected_task_obj.stdout.decode().strip()

command = filter(lambda _: selected_task in _['label'], raw_tasks)
# verify if it exists, etc

# try, etc,
to_run = list(command).pop()['command']
subprocess.run(to_run.split(" ")) # split required
